# React

React (also called React.js) is a JavaScript library used to build user interfaces ‚Äî especially for web applications.

Usage :
1. üß± Reusable Components:
You build your UI using components (small building blocks). E.g. Buttons, Menus, Forms.

2. üîÅ Efficient Updates with Virtual DOM
React updates only the parts of the screen that changed, not the whole page.

3. üåê Single Page Applications (SPAs)
SPAs load once and then update content without refreshing the whole page.

# Drawbacks :
1. No support for routing, statement management, apis, No SEO support. Need to add extra libraries

# Library vs Framework :

Library
A library is a collection of code that you call to help you do something.
You are in control. You decide when and how to use it.

Framework :
A framework is like a structure or skeleton for your project.
It calls your code, not the other way around.
The framework is in control, and you fit your code into its structure.

Feature	                Library	            Framework
Who‚Äôs in control?	      You	                The framework
Usage style	            You call it	        It calls your code
Flexibility	            More flexible	      More rules/structure

# To create React project
(In ternimal) npm create vite@latest

# To run project
(In ternimal) npm run dev

# JSX (Javascript XML)
It's a syntax that lets you write HTML code inside JavaScript.

Example :
function App() {
  return <h1>Hello, Ankit!</h1>;
}

‚ÄºÔ∏è Note :
Behind the scene, App() function is converted to plain JS using babel
function App() { 
    return React.createElement( 
        'h1', // type of element (HTML tag) 
        null, // props (none in this case) 
        'Hello, Ankit! How are you?' // children (text inside <h1>) 
    ); 
}

# JSX to rendering workflow
<.jsx file>

function Greet() {
  return (
    <div>
      <h1>This is H1</h1>
      <h2>This is H2</h2>
    </div>
  );
}

1. Babel compiles JSX to React.createElement()

function Greet() {
  return React.createElement(
    'div',
    null,
    React.createElement('h1', null, 'This is H1'),
    React.createElement('h2', null, 'This is H2 ')
  );
}

2. React creates React Element Objects (Each React.createElement(...) call returns a React Element, which is just a plain JavaScript object)

{
  type: 'div',
  props: {
    children: [
      {
        type: 'h1',
        props: {
          children: 'This is H1'
        }
      },
      {
        type: 'h2',
        props: {
          children: 'This is H2 '
        }
      }
    ]
  }
}

3. React builds the Virtual DOM Tree
React uses these objects to build a virtual DOM ‚Äî a lightweight JavaScript copy of the real DOM.
React can compare the old virtual DOM to the new one to know what changed.

VIRTUAL DOM :
{
  type: 'div',
  props: {
    children: [
      {
        type: 'h1',
        props: {
          children: 'This is H1'
        }
      },
      {
        type: 'h2',
        props: {
          children: 'This is H2'
        }
      }
    ]
  }
}

4. React renders the virtual DOM into real DOM
This tells React: ‚ÄúRender my <App /> component inside the <div id="root"> in index.html‚Äù
React converts the virtual DOM into real HTML elements and adds them to the browser.

createRoot(document.getElementById('root')).render(<App />);

‚≠êÔ∏è Components
It is like a reusable piece of UI.
It‚Äôs a function that returns some HTML (JSX).
Think of it like a building block ‚Äî just like Lego pieces.

# Why Do We Use Components?
1. Split the UI into smaller blocks
2. Re-use code easily
3. Enhances readability and maintainability.

‚≠êÔ∏è Hooks
Hooks are special functions that let you use React features (like state and lifecycle methods) inside function components.

# Why Do We Use Hooks?
Add state to function components (useState)
Run code when the component updates or mounts (useEffect)
Avoid using class components ‚Äî function components + hooks are now the standard

# Example :
useState(), useEffect(). <- THese are hooks

‚≠êÔ∏è useState()
useState() is a React Hook that lets you add and manage state (data that can change) inside a function component.
When setCount(newValue) triggers, the state changes & REACT re-renders the component to reflect the new state in the UI.

# Example :
const [count, setCount] = useState(0);

count -> state
setCount -> Function to change state.
0 -> Initial value of a state.

‚ÄºÔ∏è Note:
We can only change state using the setCount()

‚≠êÔ∏è props
Props (short for "properties") are how you send data from one component to another in React ‚Äî usually from parent to child.

# Why do we use props?
1. To re-use components with different data
2. To pass data between components(from parent to child)

# Why do we need props?
1. Every component would be hardcoded.
2. You couldn‚Äôt make flexible, reusable UIs.
3. You couldn‚Äôt send dynamic data.

# Example:

(In Parent)
<Welcome name="myTitle" desc={myObj.overview} />

(In child)
function Welcome(props) {
  return (
    <>
      <div>
        <h1>{props.name}</h1>
        <p>{props.desc}</p>
      </div>
    </>
  );
}

‚≠êÔ∏è useCallback() 
It is a React Hook that helps you avoid unnecessary re-creation of functions.
It "remembers" a function between renders unless its dependencies change.

const memoizedFn = useCallback(() => {
  // some logic
}, [dependency1, dependency2]);

# Why do we use useCallback?
In React, functions are re-created on every render.
But in some cases, it causes unnecessary work ‚Äî like:
Re-rendering child components that didn‚Äôt actually need to.
Re-calculating something heavy when it hasn‚Äôt changed.

‚≠êÔ∏è useRef()
It is a React Hook that gives you a way to hold a value across renders.
Means the value doesnt change even after the re-render.

const myRef = useRef(initialValue);

# To access value of useRef()
console.log(myRef.current)

# Why do we use useRef?
1. To access DOM elements directly

const inputRef = useRef();
<input ref={inputRef} />
<button onClick={() => inputRef.current.focus()}>Focus</button>

2. To store a value that should persist between renders ( But you don‚Äôt want React to re-render when it changes. )

const countRef = useRef(0);
countRef.current += 1; // Not triggering re-render

‚ÄºÔ∏è When useRef() updates, the component doesnt re-render like useState()

‚≠êÔ∏è useMemo()
useMemo is a React Hook that remembers the result of a calculation ‚Äî 
so it doesn‚Äôt re-run that calculation every time the component re-renders.

const memoizedValue = useMemo(() => {
  return expensiveCalculation(someValue);
}, [someValue]);

# Why do we use useMemo?
Because in React, everything inside a component runs again on every render ‚Äî even expensive operations like:
Sorting a large array
Filtering big data
Doing complex math
If the dependencies haven‚Äôt changed, you don‚Äôt want to redo that work every time. 
useMemo skips the work and returns the previous result if the dependencies are the same.

‚ÄºÔ∏è useMemo() expects its first argument to be a function that returns a value

‚≠êÔ∏è useMemo vs useCallback vs useRef
Feature     	                useMemo	                      useCallback	                                useRef
Caches a... 	                Value	                        Function	                                  Mutable value or DOM node
Dependency array?	            ‚úÖ Yes	                        ‚úÖ Yes	                                    ‚ùå No (you manage it manually)
Recalculates when?	          Dependencies change	          Dependencies change	                        You update .current manually
Re-renders on change?	        ‚ùå No	                        ‚ùå No	                                    ‚ùå No
Common use case	              Heavy computation	            Stable function for child props	            DOM refs, timers, flags, etc.

‚≠êÔ∏è useEffect
useEffect is a React Hook that lets you run side effects in your function components.(like fetching data, logging after component renders)

useEffect(() => {
  // code that runs after render
}, [dependencies]);

# Usage :

1. Runs on every component render :
useEffect(() => {
  // code that runs after render
});                                           // There is no dependency


2. Runs only once render, after the first render, and never again :
useEffect(() => {
  // code that runs after render
}, []);                                       // Keep dependency empty


3. Runs on initial render and when change in dependency
useEffect(() => {
  // code that runs after render
}, [dependency1, dependency2]);

‚≠êÔ∏è useId() [Hook]
It is a hook that generates a unique ID that stays the same across renders.

const id = useId();
<div>
  <label htmlFor={id}>{label}</label>
  <input id={id} type="text" />
</div>

‚ÄºÔ∏èNOte:
Don‚Äôt use useId for keys in lists
You get one unique value every time the component is mounted.

‚≠êÔ∏è custom hooks
A custom hook is just a function in React that uses other React hooks (like useState, useEffect, etc.) and starts with the word use.
It's a way to reuse code that uses React‚Äôs features (like state, effects, etc.) across different components.

# Why do we use it:
To avoid writing same logic again in different components( put that logic in a custom hook, and just reuse it wherever you need. ) 

# Use Case :
Calling API

‚ÄºÔ∏è We create hook file using .js/.ts

‚≠êÔ∏è React Router

# To install :
npm i react-router-dom

# Routing : (IN main.jsx)

‚ÄºÔ∏è Option 1:

import { RouterProvider, createBrowserRouter } from "react-router-dom";

const router = createBrowserRouter([
  {
    path: "/",
    element: <Layout />,
    children: [
      {
        path: "/",
        element: <Home />
      },
      {
        path: "/about",
        element: <About />
      },
      {
        path: "/contact",
        element: <Contact />
      }
    ]
  }
])

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <RouterProvider router={router} />
  </StrictMode>
);

‚ÄºÔ∏è Option 2 :

import { Route, RouterProvider, createBrowserRouter, createRoutesFromElements } from "react-router-dom";

const router = createBrowserRouter(
  createRoutesFromElements(
    <Route path="/" element={<Layout />}>
      <Route path="/" element={<Home />} />
      <Route path="/contact" element={<Contact />} />
      <Route path="/about" element={<About />} />
      <Route path="/user/:id" element={<User />} />
    </Route>
  )
)

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <RouterProvider router={router} />
  </StrictMode>
);

‚≠êÔ∏è <Link />
It is a special component from react-router-dom that lets you navigate between pages in a React app without reloading the whole page.
Similar to <a>

# Example :
import { Link } from 'react-router-dom';

<Link to="/">
  <img src="https://alexharkness.com/wp-content/uploads/2020/06/logo-2.png" alt="Logo" />
</Link>

# Usage :
<a> causes a full page reload(You lose your React state and the app restarts.). 
<Link /> changes the page without reloading(The URL updates, correct component renders instantly, It feels faster and smoother)

‚≠êÔ∏è <NavLink />
<NavLink /> is just like <Link />
The extra feature of <NavLink /> is that it can automatically highlight (or style) the link for the page you‚Äôre currently on.

# Example :
import { NavLink } from "react-router-dom";

<NavLink
  to="/about"
  className={({isActive}) => `py-2 ${isActive ? `text-orange-700` : `text-gray-700`} border-gray-100 `}
>
  About
</NavLink>

# Usage :
When building navigation menus (like a navbar or sidebar),
you usually want to show which page is active ‚Äî for example, underline it, change its color, etc.

‚≠êÔ∏è useNavigate()
It is a hook that allows us to programmatically navigate between routes in a React application

import React from "react";
import { useNavigate } from "react-router-dom";

function HomePage() {
  const navigate = useNavigate();

  const goToAbout = () => {
    navigate("/about");
  };

  return (
    <div>
      <h1>Home Page</h1>
      <button onClick={goToAbout}>Go to About</button>
    </div>
  );
}

‚≠êÔ∏è Loader
A loader is a function you attach to a route in React Router that:
Runs before the component renders.
Can fetch data, perform calculations, or do any async task.
Provides its result to the component via useLoaderData() hook.
We dont have to use useEffect and useState to call api

# Example :
S1. Define Loader Function (In github.jsx <In Same Component but outside the component function>)

export const githubDataLoader = async () => {
  const response = await fetch("https://api.github.com/users/hiteshchoudhary");
  return await response.json();
};

S2. Define loader in route (main.jsx)

<Route 
  loader={githubDataLoader}
  path="/github/" 
  element={<Github />} 
/>

S3. Get the data in component using useLoaderData() hook (github.jsx)

import { useLoaderData } from "react-router-dom";

function Github() {
  const data = useLoaderData();

  return (
    <div className="mx-auto w-full max-w-screen-xl p-4 py-6 lg:py-8 bg-gray-700 text-white my-5">
      <h1 className="text-4xl text-center mb-5">
        Github Followers: {data?.followers}
      </h1>
      <img className="mx-auto" src={data?.avatar_url} alt="" />
    </div>
  );
}


# Usage :
Fetching API data for a route (like users, products, posts).
Preloading data so your component renders with data ready.
Accessing route params (like /users/:id) and fetching data based on them.
Handling errors at the route level (React Router can catch errors thrown in a loader).


‚≠êÔ∏è Context API
The Context API in React is a built-in way to share data (state) across multiple components
without having to pass props manually through every level (a.k.a. prop drilling).

S1. Create context (src/context/ButtonContext.js)

import { createContext } from "react";
const ButtonContext = createContext();
export default ButtonContext;

S2. Create context provider (src/context/ButtonContextProvider.jsx)

function ButtonContextProvider({ children }) {
  const [buttonText, setButtonText] = useState("Ankit");
  return (
    <ButtonContext.Provider value={{ buttonText, setButtonText }}>
      {children}
    </ButtonContext.Provider>
  );
}

S3. In main.jsx

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <ButtonContextProvider>
      <App />
    </ButtonContextProvider>
  </StrictMode>
);

S4. To access context value in Component

import { useContext } from "react";
import ButtonContext from "../context/ButtonContext";

function Button() {
  const { buttonText } = useContext(ButtonContext);

  return <button>{buttonText}</button>;
}

‚ÄºÔ∏è Another Way:

S1. Create Context + Provider + custom Hook : (src/context/ButtonContext.js)

import { useContext } from "react";
import { createContext } from "react";

export const ButtonContext = createContext({
  buttonText: "Click Me",
  setButtonText: () => {},
});

export const ButtonContextProvider = ButtonContext.Provider;

export default function useButton() {
  return useContext(ButtonContext);
}

S2. Wrap <App /> with provider

function App() {
  const [buttonText, setButtonText] = useState("Hello World");

  return (
    <>
      <ButtonContextProvider value={{buttonText, setButtonText}}>
        <Home />
      </ButtonContextProvider>
    </>
  );
}

S3. Access The context value in Button.jsx

import useButton from "../context/ButtonContext.js"

function Button() {
  const { buttonText } = useButton()
  return <button>{buttonText}</button>;
}

S4. Changing the context value

function Home() {
  const inputRef = useRef();

  const { setButtonText } = useButton();

  const handleSubmit = () => {
    const value = inputRef.current.value;
    setButtonText(value);
  };

  return (
    <div style={{ border: "1px solid black" }}>
      <h1>This is Home Page</h1>
      <div>
        <input
          ref={inputRef}
          style={{ backgroundColor: "white", color: "black" }}
          type="text"
        />
        <button onClick={handleSubmit}>SUBMIT</button>
      </div>
      <Card />
    </div>
  );
}

‚≠êÔ∏è forwardRef()
forwardRef() allows you to pass a ref through parent-component to child-component
‚ùå If you try to attach a ref directly to a custom component, it doesn‚Äôt work

(Parent)

import React, { useRef } from "react";

function Parent() {
  const inputRef = useRef();

  const focusInput = () => {
    inputRef.current.focus();
  };

  return (
    <div>
      <CustomInput ref={inputRef} placeholder="Type something..." />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}

(Child)

import React, { forwardRef } from "react";

const CustomInput = forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});

‚≠êÔ∏è React Hook Form
React Hook Form is a library that helps you build and manage forms in React

# Install :
npm i react-hook-form

# Syntax :
import { useForm } from "react-hook-form";
const { 
  register,                                 // Connects an input field to the form system
  handleSubmit,                             // Handles form submission safely
  setError,                                 // To throw custom error while submission (eg. Server-side validation errors (like ‚Äúemail already exists‚Äù))
  formState: { errors }                     // Stores validation errors
} = useForm();

# register<function> in useForm()
This connects & keep track of an input field to React Hook Form.

<input {...register("email")} />
"email" : Its the name of the input field
...register() : It spreads the return value of register().
It returns an object of props : {name: "email", onChange: ∆í, onBlur: ∆í, ref: ∆í}


# Submit Form

function App() {
  const { register, handleSubmit } = useForm();

  const onSubmit = (data) => console.log(data)                  // data : { username: <value> }

  return (
    <>
      <form action="" onSubmit={handleSubmit(onSubmit)}>
        <input {...register("username")} type="text" placeholder="username" /><br />
        
        <button type="submit">SUBMIT</button>
      </form>
    </>
  );
}


# Validating Input

function App() {
  const { register, handleSubmit, formState: {errors} } = useForm();

  const onSubmit = (data) => console.log(data)

  return (
    <>
      <form action="" onSubmit={handleSubmit(onSubmit)}>
        <input {...register("username", {                                         // We can add validation as second input in register()
          required: {value: true, message: "Username is required!"},              // THis is the validation
          minLength: {value: 3, message: "Min Length should be 3"},
          maxLength: {value: 8, message: "Max Length should be 8"}
        })} type="text" placeholder="username" /><br />

        {errors.username && <div>{errors.username.message}</div> }                // To access and show input error
        
        <button type="submit">SUBMIT</button>
      </form>
    </>
  );
}

# Throw custom error (eg. Server-side validation errors (like ‚Äúemail already exists‚Äù))

function App() {
  const { register, handleSubmit, setError, clearErrors, formState: {errors} } = useForm();

  const onSubmit = (data) => {

    console.log(data);

    if(data.username != "ankit"){                                               
      setError("customError", {type: "custom", message: "Invalid Username"})                          // Here we have set custom error
    }
    
  } 

  return (
    <>
      <form action="" onSubmit={handleSubmit(onSubmit)}>
        <input {...register("username", {
          required: {value: true, message: "Username is required!"},
          minLength: {value: 3, message: "Min Length should be 3"},
          maxLength: {value: 8, message: "Max Length should be 8"},
          onChange: () => clearErrors("customError")           //To clear custom error manually. When custom error occurs it doesnt get removed even after correct password.
        })} type="text" placeholder="username" /><br />
        {errors.username && <div>{errors.username.message}</div> }

        <input {...register("password")} type="text" placeholder="password" /><br />
        
        <button type="submit">SUBMIT</button>
        {errors.customError && <div>{errors.customError.message}</div> }                              // THis will show the custom error message
      </form>
    </>
  );
}

# Add Custom validation

function App() {
  const { register, handleSubmit, setError, formState: {errors} } = useForm();

  const onSubmit = (data) => console.log(data);

  return (
    <>
      <form action="" onSubmit={handleSubmit(onSubmit)}>
        <input {...register("username", {
          required: {value: true, message: "Username is required!"},
          validate: (value) => (value === 'swapnil') || "Invalid Username"
        })} type="text" placeholder="username" /><br />

        {errors.username && <div>{errors.username.message}</div> }
        
        <button type="submit">SUBMIT</button>
      </form>
    </>
  );
}

# isSubmitting
isSubmitting is a boolean (true/false) value from formState that tells you whether the form submission is currently in progress.

useCase 1 : disabling the submit button while processing data to avoid frequent submit triggering

const {
  register,
  handleSubmit,
  formState: { errors, isSubmitting }, 
} = useForm();

<button disabled={isSubmitting} ref={submitRef} type="submit">SUBMIT</button>

useCase 2 : Render loading icon on screen while submitting

function LoginForm() {
  const {
    register,
    handleSubmit,
    formState: { isSubmitting, errors }
  } = useForm();

  const onSubmit = async (data) => {
    console.log("Submitting...", data);
    await new Promise((resolve) => setTimeout(resolve, 2000)); // simulate API delay
    console.log("Form submitted!");
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {isSubmitting && <LoadingIcon />}                                   // We can show something to the user while submitting data
      <input {...register("email", { required: "Email required" })} />
      {errors.email && <p>{errors.email.message}</p>}

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Submitting..." : "Submit"}
      </button>
    </form>
  );
}





























